#!/bin/bash

### BEGIN INIT INFO
# Provides:          globaleaks
# Required-Start:    $local_fs $remote_fs $network $named $time tor
# Required-Stop:     $local_fs $remote_fs $network $named $time
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start the GlobaLeaks server.
# Description:       Start The GlobaLeaks server, an opensource, anonymous,
#                    censorship-resistant whistleblowing platform.
### END INIT INFO

# Author: Giovanni Pellerano <evilaliv3@globaleaks.org>

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
NAME=$(basename $(readlink -nf $0))

DAEMON=/usr/bin/globaleaks
SCRIPTNAME=$0
WAITFORDAEMON=60

##################################################################
# GLobaLeaks configuration is read with the following order:
# 1) /usr/share/globaleaks/default
# 2) web configuration
# 3) /etc/default/globaleaks

# The /etc/default/globaleaks is the place where one can force
# settings that could not be overridden from the configuration
# that can be issued from the web interface
if test -e "/usr/share/globaleaks/default" ; then
    . "/usr/share/globaleaks/default"
fi

if [[ -f /var/globaleaks/globaleaks.db && "$(gl-admin getvar reachable_via_web 2>1&)" == "False" ]]; then
    TOR_SANDBOXING=1
fi

if test -e "/etc/default/globaleaks" ; then
    . "/etc/default/globaleaks"
fi

##################################################################
. /lib/init/vars.sh

. /lib/lsb/init-functions

test $DEBIAN_SCRIPT_DEBUG && set -v -x

GLPID=/var/globaleaks/globaleaks.pid

# Let's try to figure our some sane defaults:
if [ -r /proc/sys/fs/file-max ]; then
    system_max=`cat /proc/sys/fs/file-max`
    if [ "$system_max" -gt "80000" ] ; then
        MAX_FILEDESCRIPTORS=32768
    elif [ "$system_max" -gt "40000" ] ; then
        MAX_FILEDESCRIPTORS=16384
    elif [ "$system_max" -gt "10000" ] ; then
        MAX_FILEDESCRIPTORS=8192
    else
        MAX_FILEDESCRIPTORS=1024
    fi
else
    MAX_FILEDESCRIPTORS=8192
fi

wait_for_deaddaemon () {
    pid=$1
    sleep 1
    if test -n "$pid"
    then
        if kill -0 $pid 2>/dev/null
        then
            cnt=0
            while kill -0 $pid 2>/dev/null
            do
                cnt=`expr $cnt + 1`
                if [ $cnt -gt $WAITFORDAEMON ]
                then
                    log_action_end_msg 1 "still running"
                    exit 1
                fi
                sleep 1
                [ "`expr $cnt % 3`" != 2 ] || log_action_cont_msg ""
            done
        fi
    fi
    log_action_end_msg 0
}

network_sandboxing_start()
{
    log_action_begin_msg "Enabling Globaleaks Network Sandboxing"

    if ! command -v iptables >/dev/null 2>&1  || ! command -v ip6tables >/dev/null 2>&1 ; then
        log_failure_msg "GlobaLeaks Network Sandboxing Failure: requires iptables"
        exit 1
    fi

    # remove all rules with the comment: "globaleaks-network-sandboxing"
    iptables-save | grep -v "globaleaks" | iptables-restore
    ip6tables-save | grep -v "globaleaks" | ip6tables-restore

    iptables -nvL -t nat >/dev/null 2>&1
    if [ "$?" -ne "0" ]; then
        echo "GlobaLeaks Network Sandboxing Failure: missing iptables nat support"
        log_action_end_msg 1
        return
    fi

    iptables -nvL -t filter >/dev/null 2>&1
    if [ "$?" -ne "0" ]; then
        echo "GlobaLeaks Network Sandboxing Failure: missing iptables filter support"
        log_action_end_msg 1
        return
    fi

    # OUTBOUND
    if [[ "$TOR_SANDBOXING" -eq "1" ]]; then
        declare -a PORTS=("80" "443")
        for PORT in "${PORTS[@]}"; do
            iptables -m comment --comment "globaleaks" -A INPUT -p tcp -d 0.0.0.0/0 --dport $PORT -s 127.0.0.1 -j ACCEPT
            iptables -m comment --comment "globaleaks" -A INPUT -p tcp -d 0.0.0.0/0 --dport $PORT -j DROP
            ip6tables -m comment --comment "globaleaks" -A INPUT -p tcp -d :: --dport $PORT -s ::1 -j ACCEPT
            ip6tables -m comment --comment "globaleaks" -A INPUT -p tcp -d :: --dport $PORT -j DROP
        done

        # All outbound connections from GlobaLeaks goes through Tor except of allowed and enstablished connections.
        iptables -m comment --comment "globaleaks" -A OUTPUT -m state --state RELATED,ESTABLISHED -m owner --uid-owner globaleaks -d 127.0.0.1 -j ACCEPT
        ip6tables -m comment --comment "globaleaks" -A OUTPUT -m state --state RELATED,ESTABLISHED -m owner --uid-owner globaleaks -d ::1 -j ACCEPT
        iptables -m comment --comment "globaleaks" -t nat -A OUTPUT ! -o lo -p tcp -m owner --uid-owner ${USERNAME} -m tcp -j REDIRECT --to-ports 9050
        iptables -m comment --comment "globaleaks" -t filter -A OUTPUT -p tcp -m owner --uid-owner ${USERNAME} -m tcp -d 127.0.0.1 --dport 9050 -j ACCEPT
        iptables -m comment --comment "globaleaks" -t filter -A OUTPUT ! -o lo -m owner --uid-owner ${USERNAME} -j DROP
        ip6tables -m comment --comment "globaleaks" -t nat -A OUTPUT ! -o lo -p tcp -m owner --uid-owner ${USERNAME} -m tcp -j REDIRECT --to-ports 9050
        ip6tables -m comment --comment "globaleaks" -t filter -A OUTPUT -p tcp -m owner --uid-owner ${USERNAME} -m tcp -d ::1 --dport 9050 -j ACCEPT
        ip6tables -m comment --comment "globaleaks" -t filter -A OUTPUT ! -o lo -m owner --uid-owner ${USERNAME} -j DROP
    else
        # Enable enstablished connections, new connections on used tcp and udp ports
        iptables -m comment --comment "globaleaks" -A OUTPUT -m state --state RELATED,ESTABLISHED -m owner --uid-owner globaleaks -j ACCEPT
        ip6tables -m comment --comment "globaleaks" -A OUTPUT -m state --state RELATED,ESTABLISHED -m owner --uid-owner globaleaks -j ACCEPT

        declare -a PORTS=("25" "80" "53" "443" "465" "587" "9050")
        for PORT in "${PORTS[@]}"; do
            iptables -m comment --comment "globaleaks" -t filter -A OUTPUT -p tcp -m owner --uid-owner ${USERNAME} -m tcp --dport $PORT -j ACCEPT
            ip6tables -m comment --comment "globaleaks" -t filter -A OUTPUT -p tcp -m owner --uid-owner ${USERNAME} -m tcp --dport $PORT -j ACCEPT
        done

        declare -a PORTS=("53")
        for PORT in "${PORTS[@]}"; do
            iptables -m comment --comment "globaleaks" -t filter -A OUTPUT -p udp -m owner --uid-owner ${USERNAME} -m udp --dport $PORT -j ACCEPT
            ip6tables -m comment --comment "globaleaks" -t filter -A OUTPUT -p udp -m owner --uid-owner ${USERNAME} -m udp --dport $PORT -j ACCEPT
        done
    fi

    iptables -m comment --comment "globaleaks" -t filter -A OUTPUT ! -o lo -m owner --uid-owner ${USERNAME} -j DROP
    ip6tables -m comment --comment "globaleaks" -t filter -A OUTPUT ! -o lo -m owner --uid-owner ${USERNAME} -j DROP

    log_action_end_msg 0
}

network_sandboxing_stop()
{
    if ! command -v iptables >/dev/null 2>&1  || ! command -v ip6tables >/dev/null 2>&1 ; then
        log_failure_msg "GlobaLeaks Network Sandboxing Failure: requires iptables"
        exit 1
    fi

    log_action_begin_msg "Disabling GlobaLeaks Network Sandboxing"

    # remove all rules with the comment: "globaleaks-network-sandboxing"
    iptables-save | grep -v "globaleaks" | iptables-restore
    ip6tables-save | grep -v "globaleaks" | ip6tables-restore

    log_action_end_msg 0
}

globaleaks_start()
{
    if [ -n "$MAX_FILEDESCRIPTORS" ]; then
        ulimit -n "$MAX_FILEDESCRIPTORS"
    fi

    if [ ! -d "/dev/shm/gloaleaks" ]; then
        mkdir -m 700 /dev/shm/globaleaks && chown $USERNAME:$USERNAME /dev/shm/globaleaks
    fi

    ARGS="--ip=${LISTENING_IP}
          --user=${USERNAME}
          --working-path=${WORKING_DIR}"

    if start-stop-daemon --stop --quiet --pidfile $GLPID --name globaleaks; then
        log_action_end_msg 0 "already running"
    else
        if [ "${APPARMOR_SANDBOXING}" -eq "1" ]; then
            if ! command -v aa-status >/dev/null 2>&1  || ! aa-status --enabled ; then
                log_failure_msg "GlobaLeaks Apparmor Sandboxing Failure: requires apparmor"
                exit 1
            fi

            if start-stop-daemon \
                --start \
                --quiet \
                --pidfile $GLPID \
                --startas $(command -v aa-exec) \
                --exec $DAEMON \
	        -- --profile=usr.bin.globaleaks $DAEMON $ARGS
            then
                log_action_end_msg 0
            else
                log_action_end_msg 1
                exit 1
            fi
        else
            if start-stop-daemon \
                --start \
                --quiet \
                --pidfile $GLPID \
                --exec $DAEMON \
		-- $ARGS
            then
                log_action_end_msg 0
            else
                log_action_end_msg 1
                exit 1
            fi
        fi
    fi
}

globaleaks_stop()
{
    pid=`cat $GLPID 2>/dev/null` || true

    if test ! -f $GLPID -o -z "$pid"; then
        log_end_msg 0 "not running."
    else
        kill -15 $pid >/dev/null 2<&-
        wait_for_deaddaemon $pid
        log_end_msg 0 "stopped."
    fi
}

#
# Function that queries the status of the daemon/service
#
case "$1" in
  start)
    log_daemon_msg "Starting GlobaLeaks daemon" "globaleaks"

    log_action_begin_msg "Starting $DESC"

    if [[ "$NETWORK_SANDBOXING" -eq "1" ]]; then
        network_sandboxing_start
    fi

    globaleaks_start

    ;;
  stop)
    log_action_begin_msg "Stopping $DESC"


    if [[ "$NETWORK_SANDBOXING" -eq "1" ]]; then
        network_sandboxing_stop
    fi

    globaleaks_stop
    ;;
  status)
    if test ! -r $(dirname $GLPID); then
        log_failure_msg "cannot read PID file $GLPID"
        exit 4
    fi
    pid=`cat $GLPID 2>/dev/null` || true
    if test ! -f $GLPID -o -z "$pid"; then
        log_failure_msg "$NAME is not running"
        exit 3
    fi
    if ps "$pid" >/dev/null 2>&1; then
        log_success_msg "$NAME is running"
        exit 0
    else
        log_failure_msg "$NAME is not running"
        exit 1
    fi
    ;;
  restart|reload|force-reload)
    $0 stop
    sleep 1
    $0 start
    ;;
  *)
    log_action_msg "Usage: $0 {start|stop|restart|reload|force-reload|status}" >&2
    exit 1
    ;;
esac
